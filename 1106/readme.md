# Assembly 수업 요약 (1106)

## 부울 연산과 비교 명령어
AND, OR, XOR, NOT 등은 비트 단위 연산에서 주로 사용되는 명령어이며, 연산 후에는 여러 상태 플래그(ZF, CF, SF, OF, PF)에 영향을 준다.

- **Zero Flag (ZF)** : 결과가 0이면 1
- **Carry Flag (CF)** : 최상위 비트에서 올림/내림 발생 시 1
- **Sign Flag (SF)** : 결과 MSB가 1이면 1 (음수)
- **Overflow Flag (OF)** : 부호 있는 연산에서 범위를 벗어나면 1
- **Parity Flag (PF)** : 결과 하위 바이트 1의 개수가 짝수이면 1

### AND
- 두 피연산자 각 비트 간 AND 수행, 결과를 목적지에 저장
- 비트 마스크로 특정 비트 클리어 가능
- 예시: `AND AL, 11011111b` → 소문자를 대문자로 변환 가능

| X | Y | X AND Y |
|---|---|---------|
| 0 | 0 |    0    |
| 0 | 1 |    0    |
| 1 | 0 |    0    |
| 1 | 1 |    1    |

### OR
- 두 피연산자 각 비트 간 OR 수행
- 특정 비트 설정 시 유용
- 예시: `OR AL, 00000100b` → 특정 비트를 1로 설정

| X | Y | X OR Y |
|---|---|--------|
| 0 | 0 |   0    |
| 0 | 1 |   1    |
| 1 | 0 |   1    |
| 1 | 1 |   1    |

### XOR
- 두 비트 값이 같으면 0, 다르면 1
- 복원 연산 가능: `(X XOR Y) XOR Y = X`
- 패리티 검사나 암호화에 활용 가능

| X | Y | X XOR Y |
|---|---|---------|
| 0 | 0 |    0    |
| 0 | 1 |    1    |
| 1 | 0 |    1    |
| 1 | 1 |    0    |

### NOT
- 피연산자 모든 비트 반전 (1의 보수)
- 플래그 영향 없음

### TEST
- AND 연산과 같으나 결과를 저장하지 않음
- 플래그(ZF, SF, PF)만 설정

### CMP
- SUB와 동일하지만 결과를 저장하지 않음
- 플래그(ZF, CF, SF, OF)만 변함

| CMP 결과         | ZF | CF |
|-----------------|----|----|
| Dest > Src       | 0  | 0  |
| Dest < Src       | 0  | 1  |
| Dest == Src      | 1  | 0  |

- 부호 있는 비교 시 SF와 OF 관계로 판단 가능

## 플래그 직접 설정/클리어
- `STC` : Carry = 1
- `CLC` : Carry = 0
- 기타 플래그도 ST/CL 계열 명령어 존재

## 조건부 점프 (Jcond)
- 플래그 조건이 참이면 레이블로 점프
- 예: `JE/JZ`, `JNE/JNZ`, `JG`, `JL`, `JA`, `JB` 등
- ECX 값 기반 점프: `JECXZ`

## 조건부 루프
- `LOOPZ`/`LOOPE` : ZF=1이면 반복
- `LOOPNZ`/`LOOPNE` : ZF=0이면 반복

## 조건부 구조 변환 예시
고급언어의 IF/ELSEIF 구조는 어셈블리에서는 CMP + Jcond 명령어로 변환
- AND, OR 조건 적용 시 short-circuit 평가 필요
- 예: `if (A > B && C > D)` → 두 CMP + 조건부 점프

## 참고
- 어셈블리에서 IF, WHILE 등 고급 구조를 직접 사용할 수는 없으며, 조건부 점프를 통해 동일 기능 구현 가능
