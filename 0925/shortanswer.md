# 어셈블리어 복습 문제와 해설

---

## 1. 세 가지 다른 명령어 니모닉(mnemonic)의 예시
- `MOV` – 데이터를 한 위치에서 다른 위치로 복사  
- `ADD` – 두 피연산자를 더함  
- `SUB` – 한 피연산자에서 다른 피연산자를 뺌  

---

## 2. 호출 규약(Calling Convention)이란 무엇이며, 어셈블리 선언에서 어떻게 사용되는가?
**호출 규약**은 함수가 매개변수를 전달받고 반환값을 전달하는 방식을 정의한 규칙임.  
정의하는 내용:  
- 어떤 레지스터나 스택 위치에 매개변수를 넣는지  
- 스택을 호출자(caller) 또는 피호출자(callee) 중 누가 정리하는지  
- 반환값을 어떤 레지스터를 통해 전달하는지  

어셈블리 선언에서 고수준 언어와의 연동 시 `stdcall`, `cdecl` 같은 규약을 지정할 때 사용됨.  

---

## 3. 프로그램에서 스택 공간을 어떻게 예약하는가?
`.stack` 지시어를 사용하여 스택 크기를 지정함.  
예:  
```asm
.stack 4096   ; 4096바이트 크기의 스택 공간 예약
```

---

## 4. 왜 "Assembler Language"라는 용어가 정확하지 않은가?
**Assembler**는 프로그램 이름이고, 언어 자체는 **Assembly Language**라고 부름.  
따라서 "Assembler Language"라고 하면 "번역기 언어"라는 잘못된 표현이 됨.  

---

## 5. Big Endian과 Little Endian의 차이 + 용어의 기원
- **Big Endian**: 가장 상위 바이트(MSB)를 메모리의 낮은 주소에 저장  
- **Little Endian**: 가장 하위 바이트(LSB)를 메모리의 낮은 주소에 저장  

**용어 기원**: 조너선 스위프트의 소설 *걸리버 여행기*에서 알 수 있음.  
달걀을 큰 쪽(Big end)에서 깨는 사람들과 작은 쪽(Little end)에서 깨는 사람들 사이의 논쟁에서 비롯됨.  

---

## 6. 왜 정수 리터럴 대신 기호 상수(Symbolic Constant)를 쓰는가?
- 코드 가독성이 좋아짐  
- 의미 전달이 명확해짐 (예: `MAX_SIZE = 100`)  
- 유지보수가 편리함 (한 곳만 수정하면 전체 코드가 반영됨)  

---

## 7. 소스 파일과 리스팅 파일의 차이
- **소스 파일(Source File)**: 프로그래머가 작성한 어셈블리 코드  
- **리스팅 파일(Listing File)**: 어셈블러가 생성하는 파일로, 소스 코드와 기계어 번역, 주소 정보 등을 함께 포함  

---

## 8. 데이터 레이블과 코드 레이블의 차이
- **데이터 레이블(Data Label)**: 변수의 주소를 나타냄 (데이터 세그먼트)  
- **코드 레이블(Code Label)**: 명령어의 위치를 나타냄 (코드 세그먼트, 점프/호출 시 사용)  

---

## 9. (참/거짓) 식별자는 숫자로 시작할 수 없다.  
**참(True)**  

---

## 10. (참/거짓) 16진수 리터럴은 `0x3A` 형태로 쓸 수 있다.  
**참(True)**  

---

## 11. (참/거짓) 어셈블리어 지시어는 실행 시간(runtime)에 동작한다.  
**거짓(False)** – 지시어는 컴파일(어셈블) 시점에만 동작  

---

## 12. (참/거짓) 어셈블리어 지시어는 대소문자를 자유롭게 섞어서 쓸 수 있다.  
**참(True)**  

---

## 13. 어셈블리어 명령어의 네 가지 기본 부분
1. **레이블(Label)**  
2. **명령어 니모닉(Mnemonic)**  
3. **피연산자(Operands)**  
4. **주석(Comment)**  

---

## 14. (참/거짓) `MOV`는 명령어 니모닉의 예시이다.  
**참(True)**  

---

## 15. (참/거짓) 코드 레이블은 콜론(`:`)으로 끝나지만, 데이터 레이블은 콜론으로 끝나지 않는다.  
**거짓(False)** – 둘 다 콜론(`:`)으로 끝남  

---

## 16. 블록 주석 예시
```asm
COMMENT !
이 부분은 여러 줄 주석으로 처리됩니다.
프로그램 설명이나 문서화에 사용됩니다.
!
```

---

## 17. 변수 접근 시 숫자 주소를 직접 쓰는 것이 좋지 않은 이유
- 코드 가독성이 떨어짐  
- 프로그램 유지보수가 어려워짐  
- 메모리 주소가 바뀌면 코드 전체를 수정해야 함  
→ 따라서 **심볼릭 레이블**을 쓰는 것이 안전함.  

---

## 18. ExitProcess 프로시저에 전달해야 하는 인자는?
- **정수형 종료 코드(DWORD)**  

---

## 19. 어떤 지시어가 프로시저를 끝내는가?
- `ENDP`  

---

## 20. 32비트 모드에서 END 지시어의 식별자(identifier) 역할
- 프로그램 실행이 시작될 **엔트리 포인트(entry point)** 프로시저 이름을 나타냄  

---

## 21. PROTO 지시어의 목적
- 외부 프로시저의 **원형(prototype)** 을 정의하여, 호출할 때 올바른 인자 형식을 확인하도록 함  

---

## 22. (참/거짓) 객체 파일(Object file)은 링커(Linker)가 만든다.  
**거짓(False)** – 객체 파일은 어셈블러가 만듦  

---

## 23. (참/거짓) 리스팅 파일(Listing file)은 어셈블러가 만든다.  
**참(True)**  

---

## 24. (참/거짓) 링크 라이브러리는 실행 파일을 만들기 직전에 프로그램에 추가된다.  
**참(True)**  

---

## 25. 32비트 **부호 있는 정수 변수**를 만드는 데이터 지시어  
- `SDWORD`  

---

## 26. 16비트 **부호 있는 정수 변수**를 만드는 데이터 지시어  
- `SWORD`  

---

## 27. 64비트 **부호 없는 정수 변수**를 만드는 데이터 지시어  
- `QWORD`  

---

## 28. 8비트 **부호 있는 정수 변수**를 만드는 데이터 지시어  
- `SBYTE`  

---

## 29. 10바이트 **패킹된 BCD 변수**를 만드는 데이터 지시어  
- `TBYTE`  
